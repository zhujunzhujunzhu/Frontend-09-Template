# 第一步  拆分文件 
总结：
+ 为了方便文件管理，我们将parser单独拆分到文件中
+ parser接受HTML文件作为参数返回一棵DOM树


# 第二步  利用FSM实现HTML分析 
总结：
+ 我们用FSM来实现HTML的分析
+ 在HTML标准中，已经规定了HTML的状态
+ Toy—Browser只挑选其中一部分状态，完成一个最简版本


# 第三步  解析标签 
总结：
+ 开始标签  结束标签   自封闭标签 
+ 这一步暂时忽略属性


# 第四步
+ 在状态机中，除了状态迁移，我们还会加入业务逻辑
+ 我们在标签结束状态提交token


# 第五步
+ 属性分为单引号，双引号，无引号三种写法，因此需要较多的状态处理
+ 处理属性的方式跟标签类似
+ 属性结束时，我们把属性加到标签Token上


# 第六步 HTML|用token构建一个dom树
+ 从标签构建DOM树的基本的技巧是使用栈
+ 遇到开始标签 时创建元素并入栈 遇到结束标签时出栈
+ 自封闭节点可以视为入栈后立刻出栈
+ 任何元素的父元素是它入栈前的栈顶

# 第七步  HTML|将文本节点添加到DOM树
+ 文本节点与自封闭标签处理类似
+ 多个文本节点需要合并

# 第八步 css计算 | css收集规则 
环境准备   npm install css
css parser
AST

总结：
+ 遇到style标签时，我们将css规则保存起来
+ 我们调用的是css parser 来分析css规则 
+ 这里我们必须要仔细研究此库分析 css规则的格式 

# 第九步 css计算 | 添加调用 
+ 当我们创建一个元素后 立即计算css
+ 理论上，我们分析一个元素时，所有的css规则已经收集完毕 
+ 在真实的浏览器中，可能遇到写在body中的style标签，这里我们先忽略

# 第十步 css计算 | 获取父元素序列
+ 在computeCSS函数中，我们必须知道元素的所有的父元素的才能判断元素与规则是否匹配
+ 我们从上一步的stack，可以获取到本元素的所有的父元素
+ 因为我们首先获取的是“当前元素”，所以我们获得和计算父元素的匹配顺序是从内向外的


# 第十一步  css计算|选择器与元素的匹配
+ 选择器也要从当前元素向外排列 
+ 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列


# 第十二步  css计算|计算选择器与元素匹配
+ 根据选择器的类型和元素属性，计算是否与当前元素匹配
+ 这里仅仅实现了三种基本选择器，实际的浏览器中要处理复合选择器
+ 作业（可选）：实现复合选择器，实现支持空格的Class选择器


# 第十三步  
+ 一旦选择匹配 就应用选择器到元素上 形成computedStyle

# 第十四步
+ css规则根据specificity 和后来优先规则覆盖
+ specificity是个四元组，越左边权重越高
+ 一个css规则的specificity根据包含的简单选择器相加而成